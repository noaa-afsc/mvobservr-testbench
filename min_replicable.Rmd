---
title: "Minimum Replicable Process"
output: html_notebook
---

The goal here is to identify a workflow that takes a set of trip data as input and outputs a value or values that indicate an observer effect, for use in multiple iterations. 

Data are a single stratum from the obs_data_segmented.Rdata file with a reduced list of species (3). 


```{r setup}
library(dplyr)
library(FMAtools)  
```

```{r dataprep}
#results in a list split by stratum
load("source_data/1_mvglm_obs_data_segmented.Rdata") #original data

model_start <- merge(sums_l, spp_exp_segmented %>% filter(segment_new == "Keep") %>%
                       select(STRATA, Species) %>% distinct())

model_start.l <- split(model_start, f = ~ STRATA)


#extract a single stratum and reduce the number of species
x <- model_start.l$`OB FIXED BSAI` %>%
  filter(Species %in% c('Pacific Cod','Pacific Halibut','Octopus')) %>%
  select(species = Species, uid = TRIP_ID, days.fished, observed = OBSERVED_FLAG, biomass = Biomass, BLOCK, days.fished) 
```

#run original package code (for comparison)
```{r}
set.seed(123)
system.time(out_orig <- mvglm_obs(x, 
                          add_var = "days.fished",
                          block = "BLOCK",
                          n_permutations = 2,
                          )) 
out_orig$results
```
24s


#pull out code from mvglm_obs.R and simplify for replication (assuming standard inputs)
```{r}
mvglm_obs_dd <- function(profile_dat, n_permutations, xi.vec = seq(1.2, 1.8, length.out=5)) {
  
  # Specify the model formula here
  model_call <- "biomass ~ species + observed + BLOCK+days.fished"
  
  ## Determine proper family and link: -------
  t_profile <- tweedie::tweedie.profile(as.formula(model_call), #Formula from fit2 below using cpglm
                                        data = profile_dat, 
                                        #xi.vec = xi.vec,
                                        do.plot = FALSE, verbose = FALSE, method = "series",
                                        do.ci=FALSE, do.smooth = TRUE, fit.glm = FALSE,
                                        control = list(maxit = 1000, epsilon = 1e-8)) 
  #cat(paste("xi.max:", t_profile$xi.max, "\n"))
  
  # Prepare the inputs for the mvabund package functions
  
  # Replace 'biomass' with `abund` and remove `species` from the call
  model_call <- gsub("\\bbiomass\\b", "abund", model_call)
  model_call <- gsub("species \\+ ", "", model_call)
  
  # Make a wide-format version of the dataset. There is where 'uid' is important to retain.
  model_dat <- profile_dat %>%
    tidyr::pivot_wider(names_from = species, values_from = biomass, values_fill = 0) %>% arrange(BLOCK)
  abund <- mvabund::mvabund(subset(model_dat, select = unique(profile_dat$species)))
  
  # Full Model
  model_formula.full <- as.formula(model_call)
  model_dat.full <- model.frame(model_formula.full, data = model_dat)
  mv_out_full <- manyany_obs(fn = "glm", data = model_dat.full,
                             formula = model_formula.full, #interactions term allows direction to change
                             family = statmod::tweedie(var.power = as.numeric(t_profile$xi.max), link.power = 0),
                             var.power = as.numeric(t_profile$xi.max),
                             control = list(maxit = 10000), get.what = "models")
  
  
  # dd_out_full <- glm(formula=biomass ~ observed + BLOCK*days.fished,
  #                  data=profile_dat %>% filter(species=="Pacific Cod"),
  #                  family=tweedie(link.power=0, var.power=as.numeric(t_profile$xi.max)))
  
  # Reduced Model,  Removing observed flag
  model_formula.reduced <-  as.formula(gsub("observed \\+", "", model_call))
  model_dat.reduced <- model.frame(model_formula.reduced, data = model_dat)
  mv_out_reduced <- manyany_obs(fn = "glm", data = model_dat.reduced, 
                                formula = model_formula.reduced , #Note here the call is updated
                                family = statmod::tweedie(var.power = as.numeric(t_profile$xi.max), link.power = 0), 
                                var.power = as.numeric(t_profile$xi.max),
                                control = list(maxit = 10000), get.what = "models")
  
  # dd_out_reduced <- glm(formula=biomass ~ BLOCK*days.fished,
  #                  data=profile_dat %>% filter(species=="Pacific Cod"),
  #                  family=tweedie(link.power=0, var.power=as.numeric(t_profile$xi.max)))
  # 
  # dd_anova_out <- anova(dd_out_full, dd_out_reduced)
  
  #Prepare for anova
    CTRL <- permute::how(blocks = model_dat$BLOCK, within = permute::Within(type = "free")) 
  perm <- permute::shuffleSet(nset = n_permutations, n = nrow(model_dat), control = CTRL, quietly=TRUE) 
  
  anova_out <- anova_obs(mv_out_reduced, mv_out_full, bootID = perm, p.uni = "unadjusted")
  
  # Outputs ---- 
  
  return(
      results = list(
            uni.p = data.frame(t(anova_out$uni.p)),
            p = anova_out$p
            )
  )
}
```


```{r}
set.seed(123)
system.time(out_dd <- mvglm_obs_dd(x, n_permutations=10))
out_dd
```
first run (unchanged code, 2 permutations, OB FIXED BSAI, pac cod, pac hal, octopus)
  24s
remove add_var and block references (will be fixed in inputs)
  23s
do not plot tweedie profile and change increment from 0.01 to 0.05
  6s (all in the increment change)
increment to length.out = 5
  4s
drop f test on block*days or block + days (assume block*days)
  4s

10 permutations
  11s
  
1000 permutations
  1311s (20min)
  
change fit.glm=false in tweedie.profile, 10 permutations
  5s


#test different permutations
```{r, warning=FALSE, message=FALSE}
perm_test <- map_dfr(c(1, 10, 100, 1000, 10000), 
  ~{res <- mvglm_obs_dd(x, n_permutations=.x)
    data.frame(res$uni.p, p=res$p, nperm = .x)
    })

perm_test2 <- map_dfr(rep(seq(10,100,by=10), 5), 
  ~{res <- mvglm_obs_dd(x, n_permutations=.x)
    data.frame(res$uni.p, p=res$p, nperm = .x)
    })

perm_test3 <- map_dfr(rep(c(200, 500, 700, 1000), 5), 
  ~{res <- mvglm_obs_dd(x, n_permutations=.x)
    data.frame(res$uni.p, p=res$p, nperm = .x)
    })

perm_test4 <- map_dfr(rep(1:9, 5), 
  ~{res <- mvglm_obs_dd(x, n_permutations=.x)
    data.frame(res$uni.p, p=res$p, nperm = .x)
    })

perm_test5 <- map_dfr(rep(1:9, 5), 
  ~{res <- mvglm_obs_dd(x, n_permutations=.x)
    data.frame(res$uni.p, p=res$p, nperm = .x)
    })

perm_test_c <- perm_test %>%
  add_row(perm_test2 %>% select(-p)) %>%
  add_row(perm_test3 %>% select(-p)) %>%
  add_row(perm_test4 %>% select(-p))

perm_test_c %>%
  pivot_longer(cols=-nperm) %>%
  ggplot(aes(x=nperm, y=value, col=name)) +
  geom_point(alpha=0.2) +
  geom_smooth() +
  scale_x_log10() +
  labs(x='# of permutations', y='p-value')

perm_test_c %>%
  pivot_longer(cols=-nperm) %>%
  group_by(nperm, name) %>%
  summarize(sdp = sd(value),
            cvp = sd(value)/mean(value)) %>%
  ggplot(aes(x=nperm, y=cvp, col=name)) +
  geom_point(alpha=0.2) +
  geom_smooth() +
  scale_x_log10() +
  labs(x='# of permutations', y='CV of p-values')

perm_test_c %>%
  pivot_longer(cols=-nperm) %>%
  group_by(nperm, name) %>%
  summarize(sdp = sd(value),
            cvp = sd(value)/mean(value)) %>%
  ggplot(aes(x=nperm, y=sdp, col=name)) +
  geom_point(alpha=0.2) +
  geom_smooth() +
  scale_x_log10() +
  labs(x='# of permutations', y='SD of p-values')
```
















```{r manyany_obs function, eval=FALSE}
manyany_obs
function (formula, fn, family = "negative.binomial", data = NULL,
                        composition = FALSE, block = NULL, get.what = "details", 
                        var.power = NA, na.action = "na.exclude", ...) {
  
  # Modified from mavbund::manyany()
  
  if(F) {
    # For testing
    fn <- "glm"; data <- model_dat.full; formula <- model_formula.full;
    family <-  tweedie(var.power = as.numeric(t_profile$xi.max),link.power = 0);
    var.power <- as.numeric(t_profile$xi.max); control <- list(maxit = 10000);
    composition <- FALSE; block <- NULL; get.what <- "details"; na.action <- "na.exclude"
  }
  
  tol = 1e-08
  if (missing(data)) {
    mf <- model.frame(formula, parent.frame())
  } else mf <- model.frame(formula, data = data)
  yMat = model.response(mf)
  yMat = as.matrix(yMat)
  n.rows = dim(yMat)[1]
  n.vars = dim(yMat)[2]
  if (fn == "clm") {
    allargs <- match.call(expand.dots = FALSE)
    dots <- allargs$...
    if ("link" %in% names(dots)) 
      link <- dots$link
    else link = "logit"
    if (link == "loglog") 
      fam.i = binomial("cloglog")
    else fam.i = binomial(link)
    fam.i$family = "ordinal"
    fam = vector(mode = "list", length = n.vars)
    family = fam
    yMat = data.frame(yMat, stringsAsFactors = TRUE)
    for (iVar in 1:n.vars) yMat[, iVar] = as.factor(yMat[, 
                                                         iVar])
  }
  yNames = dimnames(yMat)
  if (is.null(yNames[[1]])) yNames[[1]] = 1:n.rows
  if (length(yNames) == 1) yNames[[2]] = paste("y", 1:n.vars, sep = "")
  call = match.call()
  if (composition == TRUE) {
    yVec = as.vector(yMat)
    rows = factor(rep(1:n.rows, n.vars))
    cols = factor(rep(1:n.vars, each = n.rows))
    mf = data.frame(mf[rows, ], rows, cols)
    formula = formula(paste(formula[2], "~rows+cols+cols:(", 
                            formula[3], ")", sep = ""))
    n.rows.orig = n.rows
    n.vars.orig = n.vars
    n.rows = length(yVec)
    n.vars = 1
    names(yVec) = paste(yNames[[2]][cols], ".", yNames[[1]][rows], 
                        sep = "")
    yMat = as.matrix(yVec)
    if (class(family) != "family" & length(family) > 1) 
      stop("when using composition=TRUE, family argument must have length one.")
    if (is.null(block)) 
      block = rows
    else block = block[rows]
  }
  if (class(family) == "family" || length(family) == 1) {
    fam = family
    family = vector("list", n.vars)
    for (i.var in 1:n.vars) family[[i.var]] = fam
  }
  if (length(family) != n.vars) stop("family argument has length more than one but not equal to the number of columns in yMat (!?)")
  if (length(var.power) == 1) var.power = rep(var.power, n.vars) 
  fam = family
  for (i.var in 1:n.vars) {
    if (is.character(family[[i.var]])) {
      if (family[[i.var]] == "negbinomial" || family[[i.var]] == "negative.binomial") {
        fam[[i.var]] = negative.binomial(10^6)
        fam[[i.var]]$family = family[[i.var]]
      } else if (family[[i.var]] == "binomial(link=logit)") {
        fam[[i.var]] = binomial()
        fam[[i.var]]$family = family[[i.var]]
      }
      else if (family[[i.var]] == "binomial(link=cloglog)" || 
               family[[i.var]] == "cloglog") {
        fam[[i.var]] = binomial("cloglog")
        fam[[i.var]]$family = family[[i.var]]
      }
      else {
        fam.fn = get(fam[[i.var]], mode = "function",
                     envir = parent.frame())
        fam[[i.var]] = fam.fn()
      }
    }
    if (fn == "clm") 
      fam[[i.var]] = family[[i.var]] = fam.i
    if (fam[[i.var]]$family == "binomial") 
      warning("The binomial option of manyany currently assumes you have binary (presence/absence) response")
  }
  nameOfResponse = as.character(formula[[2]])
  whichIsResponse = which(names(mf) == nameOfResponse)
  manyfit = vector(mode = "list", length = n.vars)
  fits = matrix(NA, n.rows, n.vars)
  etas = matrix(NA, n.rows, n.vars)
  params = manyfit
  logL = rep(NA, n.vars)
  for (i.var in 1:n.vars) {
    mf[[1]] = yMat[, i.var]
    manyfit[[i.var]] = do.call(fn, list(formula = formula, 
                                        family = family[[i.var]], data = mf, na.action = na.action#, ...
    ))
    logL[i.var] = logLik(manyfit[[i.var]])
    if (is.na(logL[i.var])) logL[i.var] = -0.5 * deviance(manyfit[[i.var]])
    if (get.what == "details" || get.what == "models") {
      fits[, i.var] = fitted(manyfit[[i.var]])
      etas[, i.var] = switch(fn, lmer = manyfit[[i.var]]@eta, 
                             clm = predict(manyfit[[i.var]], type = "linear.predictor", 
                                           newdata = mf)$eta1, predict(manyfit[[i.var]]))
      if (substr(fam[[i.var]]$family, 1, 3) == "bin" || fam[[i.var]]$family == "ordinal") {
        etas[, i.var] = pmax(etas[, i.var], fam[[i.var]]$linkfun(tol)/2)
        etas[, i.var] = pmin(etas[, i.var], fam[[i.var]]$linkfun(1 - 
                                                                   tol)/2)
      }
      if (fam[[i.var]]$link == "log" || fam[[i.var]]$link == "mu^0") etas[, i.var] = pmax(etas[, i.var], log(tol)/2)
      if (i.var == 1) {
        cf = try(coef(manyfit[[i.var]]), silent = TRUE)
        if (inherits(cf, "try-error")) {
          do.coef = FALSE
          coefs = NULL
        } else {
          coefs = vector(mode = "list", n.vars)
          coefs[[1]] = cf
          names(coefs[[1]]) = dimnames(cf)[[1]]
          if (composition == FALSE & n.vars > 1) names(coefs) = yNames[[2]]
          do.coef = TRUE
        }
      }
      else {
        if (do.coef == TRUE) coefs[[i.var]] = coef(manyfit[[i.var]])
      }
      if (fam[[i.var]]$family == "poisson") 
        params[[i.var]] = list(q = yMat[, i.var], lambda = fits[, 
                                                                i.var])
      if (substr(fam[[i.var]]$family, 1, 3) == "bin") 
        params[[i.var]] = list(q = yMat[, i.var], prob = fits[, 
                                                              i.var], size = 1)
      if (fam[[i.var]]$family == "Tweedie") 
        params[[i.var]] = list(q = yMat[, i.var], power = var.power[i.var], 
                               mu = fits[, i.var], phi = summary(manyfit[[i.var]])$disp)
      if (fam[[i.var]]$family == "ordinal") 
        params[[i.var]] = list(q = yMat[, i.var], mu = predict(manyfit[[i.var]], 
                                                               type = "cum.prob"), muAll = predict(manyfit[[i.var]], 
                                                                                                   type = "cum.prob", newdata = mf[-whichIsResponse])$cprob2)
      if (grepl("egative", fam[[i.var]]$family) || fam[[i.var]]$family == "negbinomial") {
        if (any(names(manyfit[[i.var]]) == "theta")) 
          theta = manyfit[[i.var]]$theta
        else {
          if (any(names(manyfit[[i.var]]) == "phi")) 
            theta = 1/manyfit[[i.var]]$phi
          else theta = 1/(fam[[i.var]]$var(1) - 1)
        }
        params[[i.var]] = list(q = yMat[, i.var], mu = fits[, 
                                                            i.var], size = theta)
      }
      if (fam[[i.var]]$family == "gaussian") {
        s.ft = summary(manyfit[[i.var]])
        if (any(names(s.ft) == "sigma")) 
          sd = s.ft$sigma
        else sd = s.ft$scale
        params[[i.var]] = list(q = yMat[, i.var], mean = fits[, 
                                                              i.var], sd = sd)
      }
    }
  }
  object = list(logL = logL, get.what = get.what)
  if (get.what == "details" || get.what == "models") {
    if (composition == TRUE) {
      fits = matrix(fits, n.rows.orig, n.vars.orig)
      etas = matrix(etas, n.rows.orig, n.vars.orig)
    } else {
      if (n.vars > 1) {
        names(logL) = yNames[[2]]
        names(params) = yNames[[2]]
      }
    }
    attributes(logL)$df = attributes(logLik(manyfit[[i.var]]))$df
    attributes(logL)$nobs = n.rows
    class(logL) = "logLik"
    # *NOTE* this function uses `runif()` and will introduce randomness and may impact reproducibility
    resids = mvabund::residuals.manyany(list(params = params, family = fam, 
                                             composition = composition, fitted.values = fits, 
                                             get.what = get.what))
    dimnames(resids) = yNames
    dimnames(fits) = yNames
    dimnames(etas) = yNames
    mf[[1]] = yMat
    object = list(logL = logL, fitted.values = fits, residuals = resids, 
                  linear.predictor = etas, family = fam, coefficients = coefs, 
                  call = call, params = params, model = mf, terms = terms(manyfit[[i.var]]), 
                  formula = formula, block = block, composition = composition, 
                  get.what = get.what)
  }
  if (get.what == "models") {
    object$fits = manyfit
    names(object$fits) = yNames[[2]]
  }
  class(object) = c("manyany", class(manyfit[[i.var]]))
  return(object)
}
```



```{r anova_obs function, eval=FALSE}
anova_obs
function(object, ..., nBoot = 99, p.uni="none", block = object1$block, 
                            nCores = 1, bootID = NULL, replace=TRUE) {
  
  # Modified from mavbund::manyany()

  if(F){
    # For testing for anova_obs
    object <- mv_out_reduced
    object2 <- mv_out_full; 
    bootID <- perm; nBoot <- 99; p.uni <- "unadjusted"; nCores <- 1; replace <- TRUE
    dots <- list(full_model = mv_out_full); ndots <- 1
  }
  
  # set default na.action to exclude in order to not change dimensions of anything when NAs are present
  naOptInit <- getOption("na.action")
  options(na.action <- "na.exclude")
  
  object1 <- object 
  
  # get object 2
  # Dont run this in testing
  dots <- list(...)
  ndots <- length(dots)
  
  fndObj2 <- FALSE
  if (ndots == 0) {
    stop("missing a second manyany object")
  } else {
    if (ndots > 1) warning("current version only compares two manyany objects")
    for (i in 1:ndots) {
      if (any(class(dots[[i]]) == "manyany")) {
        object2 <- dots[[i]]
        fndObj2 <- TRUE
        break
      }
    }
    if (!fndObj2) stop("cannot find object 2")
  }
  
  if(any(names(object1$call) == "composition")) {
    if(object1$call$composition == TRUE) { #recode so that it fits compositional models as univariate, to save time and fuss
      object1$call$formula <- object1$formula
      object2$call$formula <- object2$formula
      object1$call$data <- object1$model
      object2$call$data <- object2$model
      object1$residuals <- as.matrix(c(object1$residuals))
      object1$call$composition <- FALSE
      object2$call$composition <- FALSE
    }
  }
  
  #DW, 18/1/18: check for same composition arguments in each call
  if(all(names(object1$call) != "composition")) object1$call$composition <- FALSE
  if(all(names(object2$call) != "composition")) object2$call$composition <- FALSE
  
  if(object1$call$composition != object2$call$composition) stop("Sorry, either both manyany objects will need to be compositional, or neither")
  
  n.rows <- dim(object1$resid)[1]
  n.vars <- dim(object1$resid)[2]
  
  qfn <- rep(NA,n.vars)
  for(i.var in 1:n.vars){
    if(grepl("egative",object1$family[[i.var]]$family) || object1$family[[i.var]]$family == "negbinomial") qfn[i.var] <- "qnbinom"
    if(object1$family[[i.var]]$family == "poisson") qfn[i.var] <- "qpois"
    if(object1$family[[i.var]]$family == "binomial"){
      qfn[i.var] <- "qbinom"
      warning("The binomial option of manyany currently assumes you have presence/absence data")
    } 
    if(object1$family[[i.var]]$family == "gaussian") qfn[i.var] <- "qnorm"  
    if(object1$family[[i.var]]$family == "Tweedie") qfn[i.var] <- "qtweedie_obs"   # *[NOTE] Using custom qtweedie_obs*
    if(object1$family[[i.var]]$family == "ordinal") qfn[i.var] <- "qordinal"
  }
  
  if(is.null(bootID) == FALSE) {
    bootID <- as.matrix(bootID)
    if(dim(bootID)[2] != n.rows) stop("Number of columns of bootID must match number of rows in data")
    nBoot = dim(bootID)[1] #overwriting nBoot with value implied by user-entered ID matrix
    block = NULL #overwriting previous value for block
    print("User-entered bootID matrix will be used to generate bootstrap samples")
  }  
  n.levels <- n.rows; unlistIDs = NULL #objects needed for block resampling otherwise ignorable 
  blockIDs <- NULL
  
  if(is.null(block) == FALSE) {
    tb <- table(block)
    n.levels <- length(tb)
    if(any(tb != n.rows/n.levels)) {   
      print(tb) 
      stop("Sorry, block needs to be a balanced factor - same number of rows for each level")
    } else {
      blockIDs <- vector("list",n.levels)
      for(i.level in 1:n.levels) {
        blockIDs[[i.level]] <- which(block == names(tb)[i.level])
      }
      unlistIDs <- unlist(blockIDs) #needed to match each resampled observation with its correct location
    }
  }
  #get observed test stat
  #ft.1i=eval(object1$call) #this call not needed but good to check that eval is working, compare logLik to logLik(object1)
  statj <- 2 * ( logLik(object2) - logLik(object1) )
  stat <- sum(statj)
  
  if(nCores > 1) {
    nBooti <- ceiling(nBoot/nCores)
    
    # construct a list which says which rows of bootID to use in which cluster: only needed when bootID provided
    bootRows <- vector(length = nCores, mode = "list")
    for(iCore in 1:nCores) {
      bootRows[[iCore]] <- 1:nBooti + nBooti * (iCore - 1)
      bootRows[[nCores]] <- pmin( bootRows[[nCores]], nBoot )
    }
    
    # set up clusters, pass through arguments
    cl <- parallel::makeCluster(nCores)
    argList <- list(bootID = bootID, 
                    block = block, 
                    blockIDs = blockIDs, 
                    n.rows = n.rows, 
                    n.vars = n.vars, 
                    replace = replace, 
                    unlistIDs = unlistIDs, 
                    n.levels = n.levels, 
                    object1 = object1, 
                    object2 = object2, 
                    qfn = qfn)
    
    parallel::clusterExport(cl,"argList", envir = environment())
    #clusterExport(cl,c("nBooti","bootID","block","n.rows","n.vars","replace","unlistIDs","n.levels","object1","object2","qfn"), envir=environment())
    out <- parallel::parLapply(cl, bootRows, bootAnova_obs)
    #why not clusterapply??
    parallel::stopCluster(cl)
    
    # store results in vectors/matrices not lists
    stat.i  <- rep(NA, nBooti * nCores)
    statj.i <- matrix(NA, n.vars, nBooti * nCores)
    for(i.core in 1:nCores) {
      stat.i[(i.core-1) * nBooti + 1:nBooti] <- out[[i.core]]$stati.i
      statj.i[,(i.core-1) * nBooti + 1:nBooti] <- out[[i.core]]$statj.ii
    }  
    stat.i <- stat.i[1:nBoot]
    statj.i <- statj.i[,1:nBoot]
  } else {
    # bootAnova_obs runs here
    out <- bootAnova_obs(bootRows = 1:nBoot, 
                        bootID = bootID,
                        block = block, 
                        blockIDs = blockIDs, 
                        n.rows = n.rows,
                        n.vars = n.vars,
                        replace = replace,
                        unlistIDs = unlistIDs,
                        n.levels = n.levels,
                        object1 = object1,
                        object2 = object2,
                        qfn = qfn,
                        nCores = 1)
    stat.i <- out$stati.i
    statj.i <- out$statj.ii
  }
  if(n.vars > 1) {
    dimnames(statj.i)[[1]] <- dimnames(object1$residuals)[[2]]
    # CF Suggested correction, and apply below
    # If length of stat.i = nBoot, my correction will work
    # nBoot is the number of rows in bootID (l. 81)
    # stati is from stati.i which is a rep(NA of nBooti). 
    # nBooti is length(bootRows).
    # bootRows = 1:nBoot.  Yes, they are equal.
    nBootSuccess <- as.numeric(length(stat.i[!is.na(stat.i)])) #Number of successful bootstraps
    
    # p = (1 + sum(stat.i > stat - 1.e-8) ) / (nBoot + 1)  OLD.  This seems strange at low nBoot numbers.  
    #                                                           Consider nBoot = 1, p = 0.5!  Need at least 100 nBoot!
    # The old way will no longer work because for failed model bootstraps we have NAs in stat.i.  
    # So although we did two bootstraps, only one has a stat.i
    p <- (1 + sum(stat.i > (stat - 1.e-8), na.rm = TRUE) ) / (nBootSuccess + 1) 
    # The na.rm = T above converts stat.i to successful model runs.
    
    if(length(statj) > 1) {
      # pj = (1 + apply(statj.i > statj-1.e-8, 1, sum) ) / (nBoot + 1)
      pj <- (1 + apply(statj.i > (statj - 1.e-8), 1, sum, na.rm = TRUE) ) / (nBootSuccess + 1) 
      # Same as p applied to each species (row).
    }
  } else {
    # pj = (1 + sum(statj.i > statj-1.e-8) ) / (nBoot + 1) OLD
    pj <- (1 + sum(statj.i > (statj - 1.e-8), na.rm = TRUE) ) / (nBootSuccess + 1)
  }
  
  class(stat.i) <- "numeric"
  
  if(p.uni == "unadjusted") {
    result <- list(stat = stat,
                   p = p,
                   uni.test = statj,
                   uni.p = pj,
                   stat.i = stat.i,
                   statj.i = statj.i,
                   p.uni = p.uni,
                   nBoot = nBoot,
                   nBootSuccess = nBootSuccess) # Adding Successes to output.
  }
  
  if(p.uni == "none") {
    result <- list(stat = stat,
                   p = p,
                   stat.i = stat.i,
                   p.uni = p.uni,
                   nBoot = nBoot,
                   nBootSuccess = nBootSuccess) # Adding Successes to output.
  }
  
  options(na.action = naOptInit) #restore previous default for na.action
  
  #class(result) <- "anova_obs"
  result
  
}
```

```{r bootAnova_obs function, eval=FALSE}
bootAnova_obs
function(bootRows, ...){
  
  if(F){
    # For testing bootAnova_obs
    bootRows <- 1:nBoot; argList = list(
      bootID = bootID, block = block, blockIDs = blockIDs,
      n.rows = n.rows, n.vars = n.vars,
      replace = replace, unlistIDs = unlistIDs, n.levels = n.levels,
      object1 = object1, object2 = object2, qfn = qfn, nCores = 1
    )
  }
  
  nBooti = length(bootRows)
  
  # Don't run this in testing
  dots = list(...)
  if ( any(names(dots) == "nCores") ) { # if nCores=1, take ... and call it argList, to match parLapply call
    if(dots$nCores == 1) argList <- list(...)
  }
  #initialise parameters for bootstrapping
  
  #require(mvabund)
  yMat = matrix(NA, argList$n.rows, argList$n.vars)
  #next two lines no longer correct, requires matrix input to use formula
  #  if(argList$object1$family[[1]]$family=="ordinal") 
  #    yMat=data.frame(yMat)
  argList$object1$call$get.what <- "none" #to avoid wasting time computing residuals etc when resampling
  argList$object2$call$get.what <- "none" #to avoid wasting time computing residuals etc when resampling
  
  if(is.null(argList$bootID)) boot.Resamp <- rep(NA,argList$n.rows)
  
  # find where in object1$call and object2$call the response matrix is so it can be replaced with bootstrapped version
  mf              <- argList$object2$model
  nameOfResponse  <- as.character(argList$object2$formula[[2]])
  whichIsResponse <- which(names(mf) == nameOfResponse)
  
  # Geoff used apply functions to replace the loop
  out.lst <- apply(argList$bootID, 1, function(x) {
    # x <- argList$bootID[1, ]
    
    yMat <- mapply(
      function(y, z, fun) {
        # y <- apply(argList$object1$residuals, 2, function(y0) as.vector(y0[x]), simplify = F)[[1]]; z <- argList$object1$params[[1]]; fun <- argList$qfn[[1]]
        z$p <- y
        z$q <- NULL
        do.call(fun, z)  #' *This is still where the hold up is! qtweedie*
      },
      y = apply(pnorm(argList$object1$residuals), 2, function(y0) y0[x], simplify = F),
      z = argList$object1$params,
      fun = argList$qfn,                 #' *MAKE SURE THIS GETS qtweedie_obs!*
      # fun = rep("qtweedie_obs", times = 34),  # For testing #
      USE.NAMES = F
    )
    
    #save resampled yMat as whatever the original yMat was called in workspace - but without zerotons
    if(argList$object1$family[[1]]$family=="ordinal") {
      is.zeroton <- apply(yMat,2,function(x) length(table(x)))==1 
    } else is.zeroton <- apply(yMat,2,sum,na.rm=TRUE)==0
    
    # replace response matrix:
    mf[[whichIsResponse]] <- yMat[, is.zeroton==FALSE]
    
    # *[NOTE]* In a function, we want to basically re-run our previous analyses, but we don't have the necessary 
    # objects inside this function environment. We need to fill this environment with data objects of the same names 
    # but with replaced data, we need the formulas used for the full and reduced models, and we need the t_profile 
    # object. The last one is the trickiest, but we can pull it from the function environment that created the models.
    
    assign(deparse(argList$object1$call$data), mf)  # Creates "model_dat.reduced" object as new mf
    assign(deparse(argList$object2$call$data), mf)  # Creates "model_dat.full" object as new mf
    
    model_formula.reduced <- argList$object1$formula
    model_formula.full <- argList$object2$formula
    
    # Need t_profile as well! This was the same between the reduced and full models
    t_profile <- get("t_profile",  envir = attributes(argList$object1$formula)$.Environment )
    
    # Assign null values to outputs.
    stati.i  <- NA
    statj.ii <- rep(NA, times = argList$n.vars)
    
    #re-fit manyany functions and calculate test stats using the resampled yMat:
    if(sum(is.zeroton == FALSE) > 0) {
      #      recover()  
      # Here object1$call and object2$call models have been placed inside of tryCatch.  If model fails, NA results.
      ft.1i <-  tryCatch(expr = eval(argList$object1$call), error = function(cond){NA}) 
      ft.2i <-  tryCatch(expr = eval(argList$object2$call), error = function(cond){NA}) 
      # Above is working for the case where model converges.  Not yet workinig for error condition.
      
      if(length(ft.1i) > 1 & length(ft.2i) > 1) {
        #The above argument limits the calculation of statj.ii and stati.i for working models only
        #A counter argument is not needed because the blank matrix is already NAs!
        statj.ii[is.zeroton == FALSE] <- 2 * (logLik(ft.2i) - logLik(ft.1i))
        stati.i <- sum(statj.ii, na.rm = TRUE)
      } 
      # This na.rm = TRUE in the line above must be in case a species is missing or fails?  However this doesn't seem right
      # to sum different amounts across species for stati.i?
    } else stati.i <- 0
    
    list(
      statj.ii = statj.ii,
      stati.i = stati.i
    )
  })
  
  # Create final list of outputs
  list(
    stati.i = sapply(out.lst, "[[", "stati.i"),
    statj.ii = sapply(out.lst, "[[", "statj.ii")
  )
  
}
```

